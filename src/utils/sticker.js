const axios = require('axios');
const { randomBytes } = require('crypto');
const Image = require('node-webpmux').Image;
const config = require("@config")

// by hardianto
const setting = {
  sessionInfo: {
    WA_VERSION: '2.2106.5',
    PAGE_UA: 'WhatsApp/2.2037.6 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36',
    WA_AUTOMATE_VERSION: '3.6.10 UPDATE AVAILABLE: 3.6.11',
    BROWSER_VERSION: 'HeadlessChrome/88.0.4324.190',
    OS: 'Windows Server 2016',
    START_TS: 1614310326309,
    NUM: '6247',
    LAUNCH_TIME_MS: 7934,
    PHONE_VERSION: '2.20.205.16',
  },
  config: {
    sessionId: 'session',
    headless: true,
    qrTimeout: 20,
    authTimeout: 0,
    cacheEnabled: false,
    useChrome: true,
    killProcessOnBrowserClose: true,
    throwErrorOnTosBlock: false,
    chromiumArgs: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--aggressive-cache-discard',
      '--disable-cache',
      '--disable-application-cache',
      '--disable-offline-load-stale-cache',
      '--disk-cache-size=0'
    ],
    executablePath: 'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
    skipBrokenMethodsCheck: true,
    stickerServerEndpoint: true,
  },
};

/**
 * Sets the EXIF data for a webp sticker.
 * 
 * @param {Buffer} webpSticker - The webp sticker buffer.
 * @param {string} packname - The name of the sticker pack.
 * @param {string} author - The author of the sticker pack.
 * @param {Object} [extra={}] - Additional metadata for the sticker pack.
 * @returns {Promise<Buffer>} - The buffer of the webp sticker with EXIF data.
 */
exports.setExif = async (webpSticker, packname, author, extra = {}) => {
  return new Promise(async (resolve, reject) => {
    try {
      const img = new Image();
      const stickerPackId = randomBytes(16).toString('hex').slice(0, 8);
      const json = {
        'sticker-pack-id': stickerPackId,
        'sticker-pack-name': author,
        'sticker-pack-publisher': packname,
        'sticker-pack-publisher-id': packname,
        'sticker-pack-version': '1.0.0',
        'android-app-store-link': config.api.url,
        'ios-app-store-link': config.api.url,
        'sticker-pack-description': `This sticker is a sticker that has been generated by ${config.bot.name}`,
        emojis: ['â¤', 'ğŸ˜', 'ğŸ˜˜', 'ğŸ’•', 'ğŸ˜»', 'ğŸ’‘', 'ğŸ‘©â€â¤â€ğŸ‘©', 'ğŸ‘¨â€â¤â€ğŸ‘¨', 'ğŸ’', 'ğŸ‘©â€â¤â€ğŸ’‹â€ğŸ‘©', 'ğŸ‘¨â€â¤â€ğŸ’‹â€ğŸ‘¨', 'ğŸ§¡', 'ğŸ’›', 'ğŸ’š', 'ğŸ’™', 'ğŸ’œ', 'ğŸ–¤', 'ğŸ’”', 'â£', 'ğŸ’', 'ğŸ’“', 'ğŸ’—', 'ğŸ’–', 'ğŸ’˜', 'ğŸ’', 'ğŸ’Ÿ', 'â™¥', 'ğŸ’Œ', 'ğŸ’‹', 'ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘©', 'ğŸ‘¨â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨', 'ğŸ‘©â€â¤ï¸â€ğŸ‘¨', 'ğŸ‘©â€â¤ï¸â€ğŸ‘©', 'ğŸ‘¨â€â¤ï¸â€ğŸ‘¨', 'ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨', 'ğŸ‘¬', 'ğŸ‘­', 'ğŸ‘«', 'ğŸ¥°', 'ğŸ˜š', 'ğŸ˜™', 'ğŸ‘„', 'ğŸŒ¹', 'ğŸ˜½', 'â£ï¸', 'â¤ï¸', 'ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ˜‚', 'ğŸ¤£', 'ğŸ™‚', 'ğŸ˜›', 'ğŸ˜', 'ğŸ˜œ', 'ğŸ¤ª', 'ğŸ¤—', 'ğŸ˜º', 'ğŸ˜¸', 'ğŸ˜¹', 'â˜º', 'ğŸ˜Œ', 'ğŸ˜‰', 'ğŸ¤—', 'ğŸ˜Š', 'ğŸŠ', 'ğŸ‰', 'ğŸ', 'ğŸˆ', 'ğŸ‘¯â€â™‚ï¸', 'ğŸ‘¯', 'ğŸ‘¯â€â™€ï¸', 'ğŸ’ƒ', 'ğŸ•º', 'ğŸ”¥', 'â­ï¸', 'âœ¨', 'ğŸ’«', 'ğŸ‡', 'ğŸ†', 'ğŸ»', 'ğŸ¥‚', 'ğŸ¾', 'ğŸ‚', 'ğŸ°', 'â˜¹', 'ğŸ˜£', 'ğŸ˜–', 'ğŸ˜«', 'ğŸ˜©', 'ğŸ˜¢', 'ğŸ˜­', 'ğŸ˜', 'ğŸ˜”', 'ğŸ˜Ÿ', 'ğŸ˜•', 'ğŸ˜¤', 'ğŸ˜ ', 'ğŸ˜¥', 'ğŸ˜°', 'ğŸ˜¨', 'ğŸ˜¿', 'ğŸ˜¾', 'ğŸ˜“', 'ğŸ™â€â™‚', 'ğŸ™â€â™€', 'ğŸ’”', 'ğŸ™', 'ğŸ¥º', 'ğŸ¤•', 'â˜”ï¸', 'â›ˆ', 'ğŸŒ©', 'ğŸŒ§,ğŸ˜¯', 'ğŸ˜¦', 'ğŸ˜§', 'ğŸ˜®', 'ğŸ˜²', 'ğŸ™€', 'ğŸ˜±', 'ğŸ¤¯', 'ğŸ˜³', 'â—', 'â•', 'ğŸ¤¬', 'ğŸ˜¡', 'ğŸ˜ ', 'ğŸ™„', 'ğŸ‘¿', 'ğŸ˜¾', 'ğŸ˜¤', 'ğŸ’¢', 'ğŸ‘º', 'ğŸ—¯ï¸', 'ğŸ˜’', 'ğŸ¥µ', 'ğŸ‘‹'],
        ...extra,
      };

      let exifAttr = Buffer.from([0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);
      let jsonBuffer = Buffer.from(JSON.stringify(json), 'utf8');
      let exif = Buffer.concat([exifAttr, jsonBuffer]);
      exif.writeUIntLE(jsonBuffer.length, 14, 4);
      
      await img.load(webpSticker);
      img.exif = exif;
      resolve(await img.save(null));
    } catch (error) {
      reject(error);
    }
  });
};

/**
 * Creates a sticker from an image or video file.
 * 
 * @param {Buffer | String} file - The input file buffer or path.
 * @param {Object} [data={author: '', pack: '', keepScale: true, removebg: 'HQ', circle: false}] - Configuration options for the sticker.
 * @returns {Promise<Buffer>} - The buffer of the created sticker.
 */
exports.makeSticker = async (file, data = { author: '', pack: '', keepScale: true, removebg: 'HQ', circle: false }) => {
  return new Promise(async (resolve, reject) => {
    try {
      const buffer = await conn.toBuffer(file);
      if (buffer.mime === 'image/webp') {
        resolve(await this.setExif(buffer.buffer, data.author, data.pack));
        return;
      }

      const config2 = {
        ...data,
        processOptions: {
          crop: !data.keepScale,
          fps: 10,
          startTime: '00:00:00.0',
          endTime: '00:00:7.0',
          loop: 0,
        },
      };

      const DEFAULT_URL = 'https://sticker-api.openwa.dev/';
      const Type = buffer.mime.includes('image') ? 'image' : 'file';
      const url = `${DEFAULT_URL}${Type === 'image' ? 'prepareWebp' : 'convertMp4BufferToWebpDataUrl'}`;

      const { data: responseData } = await axios.post(url, JSON.stringify({
        ...setting,
        stickerMetadata: config2,
        [Type]: `data:${buffer.mime};base64,${buffer.buffer.toString('base64')}`,
      }), {
        headers: {
          Accept: 'application/json, text/plain, */*',
          'Content-Type': 'application/json;charset=utf-8',
          'User-Agent': 'WhatsApp/2.2037.6 Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36',
        },
        maxBodyLength: Infinity,
        maxContentLength: Infinity,
      });

      if (Type === 'image') {
        resolve(await this.setExif(Buffer.from(responseData.webpBase64, 'base64'), data.author, data.pack));
      } else {
        const webpBase = responseData.replace(/^data:(.*?);base64,/, '').replace(/ /g, '+');
        const fileBuffer = Buffer.from(webpBase, 'base64');
        resolve(await this.setExif(fileBuffer, data.author, data.pack));
      }
    } catch (error) {
      reject(error);
    }
  });
};
